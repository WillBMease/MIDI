<!doctype html>
<html>
	<head>
		<title> Socket.IO chat </title>
		<style>
			* { margin: 0; padding: 0 box-sizing: border-box; }
			body { font: 13px Helvetica, Arial; }
			form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
			form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
			form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
			#messages { list-style-type: none; margin: 0; padding: 0; }
			#messages li { padding: 5px 10px; }
			#messages li:nth-child(odd) { background: #eee; }
		</style>
	</head>
	<body>
		<ul id = "messages"></ul>
		<form action = "">
			<input id = "m" autocomplete = "off" /><button>Send</button>
		</form>
		<audio id="audiotag1" src="a.m4a" preload="auto"></audio>
		<script src = "/socket.io/socket.io.js"></script>
		<script src="http://code.jquery.com/jquery-1.11.1.js"></script>
		<script>

    var audio = {
        buffer: {},
        compatibility: {},
        files: [
            'synth.wav',
            'beat.wav'
        ],
        proceed: true,
        source_loop: {},
        source_once: {}
    };

    //-----------------
    // Audio Functions
    //-----------------
    audio.findSync = function(n) {
        var first = 0,
            current = 0,
            offset = 0;

        // Find the audio source with the earliest startTime to sync all others to
        for (var i in audio.source_loop) {
            current = audio.source_loop[i]._startTime;
            if (current > 0) {
                if (current < first || first === 0) {
                    first = current;
                }
            }
        }

        if (audio.context.currentTime > first) {
            offset = (audio.context.currentTime - first) % audio.buffer[n].duration;
        }

        return offset;
    };

    audio.play = function(n) {
        if (audio.source_loop[n]._playing) {
            audio.stop(n);
        } else {
            audio.source_loop[n] = audio.context.createBufferSource();
            audio.source_loop[n].buffer = audio.buffer[n];
            audio.source_loop[n].loop = true;
            audio.source_loop[n].connect(audio.context.destination);

            var offset = audio.findSync(n);
            audio.source_loop[n]._startTime = audio.context.currentTime;

            if (audio.compatibility.start === 'noteOn') {
                /*
                The depreciated noteOn() function does not support offsets.
                Compensate by using noteGrainOn() with an offset to play once and then schedule a noteOn() call to loop after that.
                */
                audio.source_once[n] = audio.context.createBufferSource();
                audio.source_once[n].buffer = audio.buffer[n];
                audio.source_once[n].connect(audio.context.destination);
                audio.source_once[n].noteGrainOn(0, offset, audio.buffer[n].duration - offset); // currentTime, offset, duration
                /*
                Note about the third parameter of noteGrainOn().
                If your sound is 10 seconds long, your offset 5 and duration 5 then you'll get what you expect.
                If your sound is 10 seconds long, your offset 5 and duration 10 then the sound will play from the start instead of the offset.
                */

                // Now queue up our looping sound to start immediatly after the source_once audio plays.
                audio.source_loop[n][audio.compatibility.start](audio.context.currentTime + (audio.buffer[n].duration - offset));
            } else {
                audio.source_loop[n][audio.compatibility.start](0, offset);
            }

            audio.source_loop[n]._playing = true;
        }
    };

    audio.stop = function(n) {
        if (audio.source_loop[n]._playing) {
            audio.source_loop[n][audio.compatibility.stop](0);
            audio.source_loop[n]._playing = false;
            audio.source_loop[n]._startTime = 0;
            if (audio.compatibility.start === 'noteOn') {
                audio.source_once[n][audio.compatibility.stop](0);
            }
        }
    };





			var socket = io() ;
			$('form').submit(function(){
				socket.emit('chat message', $('#m').val());
				$('#m').val('');
				return false ;
			});
			socket.on('chat message', function(msg){
				$('#messages').append($('<li>').text(msg));




// 	var context = new webkitAudioContext(); // Create audio container with webkit prefix
// 	oscillator = context.createOscillator(); // Create bass guitar
//     gainNode = context.createGainNode(); // Create boost pedal
 
// 	oscillator.connect(gainNode); // Connect bass guitar to boost pedal
// 	gainNode.connect(context.destination); // Connect boost pedal to amplifier
// 	gainNode.gain.value = 0.3; // Set boost pedal to 30 percent volume
// //oscillator.noteOn(0); // Play bass guitar instantly


// setInterval(function(){oscillator.noteOn(0);},300);
// setInterval(function(){oscillator.noteOff(0);},400) ;

// setTimeout(function(){
// oscillator.noteOff(0) ;
// }, 100)

// function createSource(buffer) {
//   var source = context.createBufferSource();
//   var gainNode = context.createGainNode();
//   source.buffer = buffer;
//   // Connect source to gain.
//   source.connect(gainNode);
//   // Connect gain to destination.
//   gainNode.connect(context.destination);

//   return {
//     source: source,
//     gainNode: gainNode
//   };
// }

// function playHelper(buffers, iterations, fadeTime) {
//   var currTime = context.currentTime;
//   for (var i = 0; i < iterations; i++) {
//     // For each buffer, schedule its playback in the future.
//     for (var j = 0; j < buffers.length; j++) {
//       var buffer = buffers[j];
//       var duration = buffer.duration;
//       var info = createSource(buffer);
//       var source = info.source;
//       var gainNode = info.gainNode;
//       // Fade it in.
//       gainNode.gain.linearRampToValueAtTime(0, currTime);
//       gainNode.gain.linearRampToValueAtTime(1, currTime + fadeTime);
//       // Then fade it out.
//       gainNode.gain.linearRampToValueAtTime(1, currTime + duration-fadeTime);
//       gainNode.gain.linearRampToValueAtTime(0, currTime + duration);

//       // Play the track now.
//       source.noteOn(currTime);

//       // Increment time for the next iteration.
//       currTime += duration - fadeTime;
//     }
//   }
// }
try {
        // More info at http://caniuse.com/#feat=audio-api
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audio.context = new window.AudioContext();
    } catch(e) {
        audio.proceed = false;
        alert('Web Audio API not supported in this browser.');
    }

    if (audio.proceed) {
        //---------------
        // Compatibility
        //---------------
        (function() {
            var start = 'start',
                stop = 'stop',
                buffer = audio.context.createBufferSource();

            if (typeof buffer.start !== 'function') {
                start = 'noteOn';
            }
            audio.compatibility.start = start;

            if (typeof buffer.stop !== 'function') {
                stop = 'noteOff';
            }
            audio.compatibility.stop = stop;
        })();

        //-------------------------------
        // Setup Audio Files and Buttons
        //-------------------------------
        for (var a in audio.files) {
            (function() {
                var i = parseInt(a) + 1;
                var req = new XMLHttpRequest();
                req.open('GET', audio.files[i - 1], true); // array starts with 0 hence the -1
                req.responseType = 'arraybuffer';
                req.onload = function() {
                    audio.context.decodeAudioData(
                        req.response,
                        function(buffer) {
                            audio.buffer[i] = buffer;
                            audio.source_loop[i] = {};
                            var button = document.getElementById('button-loop-' + i);
                            button.addEventListener('click', function(e) {
                                e.preventDefault();
                                audio.play(this.value);
                            });
                        },
                        function() {
                            console.log('Error decoding audio "' + audio.files[i - 1] + '".');
                        }
                    );
                };
                req.send();
            })();
        }
    }

			});
		</script>
	</body>
</html>